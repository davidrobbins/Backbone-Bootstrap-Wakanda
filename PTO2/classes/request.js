//Creating the Request classmodel.Request = new DataClass("Requests");//Add Task attributes.model.Request.id = new Attribute("storage", "long", "key auto");model.Request.hours = new Attribute("storage", "long", "btree");model.Request.compensation = new Attribute("storage", "string", "btree");model.Request.dateString = new Attribute("storage", "string");model.Request.dateRequested = new Attribute("storage", "date", "btree");model.Request.status = new Attribute("storage", "string", "btree");model.Request.payrollChecked = new Attribute("storage", "bool");//So manager can approve request via email.model.Request.approveID = new Attribute("storage", "uuid", {scope: "publicOnServer"}); //{scope: "publicOnServer", autogenerate: true}model.Request.approveHA1Key = new Attribute("storage", "string");model.Request.approvePassword = new Attribute("storage", "string");model.Request.owner = new Attribute("relatedEntity", "User", "User"); // relation to the User classmodel.Request.ownerName = new Attribute("alias", "string", "owner.fullName");//Collection Methods.model.Request.collectionMethods = {};model.Request.collectionMethods.acceptAllRequests = function() {	var currentRequestsCollection = this; //"this" contains our current Requests collection.	currentRequestsCollection.forEach(function(oneRequest) {		oneRequest.status = "Accepted";        oneRequest.save();	}); //end - currentRequestsCollection.forEach().		return currentRequestsCollection;}; //end - model.Request.collectionMethods.acceptRequests().model.Request.collectionMethods.acceptAllRequests.scope = "public";//Class methods.model.Request.methods = {};model.Request.methods.calendarAllRequests = function() {	var sessionRef = currentSession(),	promoteToken = sessionRef.promoteWith("Administrator"); //temporarily make this session Admin level.	return ds.Request.all();	sessionRef.unPromote(promoteToken); //Put the session back to normal.};//Class methods scope.model.Request.methods.calendarAllRequests.scope ="public";//Eventsmodel.Request.events = {};model.Request.events.onRestrictingQuery = function() {		var myCurrentUser = currentUser(), // we get the user of the current session.		sessionRef = currentSession(), // Get session.		result;		result = ds.Request.createEntityCollection(); //default to empty collection.		if (sessionRef.belongsTo("Administrator") || sessionRef.belongsTo("Manager")) {		result = ds.Request.all();	} else {		result = ds.Request.query("owner.id = :1", myCurrentUser.ID);	}		return result;} //end - onRestrictingQuery();model.Request.events.onInit = function() {	var myCurrentUser = currentUser(), // we get the user of the current session.		myUser = ds.User.find("id = :1", myCurrentUser.ID);		if ((myCurrentUser !== null) && (myUser !== null)) {//if a user is logged in.				this.owner = myUser;	}		this.status = "Pending";	this.payrollChecked = false;		this.approvePassword = PTO.makeid();	this.approveID = generateUUID();    this.approveHA1Key = directory.computeHA1(this.approveID, this.approvePassword);}; //end - onInit().model.Request.events.onValidate = function() {	var err = null,		sessionRef = currentSession();	//	if (sessionRef.user.name === "default guest") {//		err = {error : 3010, errorMessage: "Invalid session. Please refresh your browser."};//		return err;//	}	 	// Get the session.	var	myCurrentUser = currentUser(), // Get the current user.		myUser = ds.User.find("id = :1", myCurrentUser.ID);		if (myUser) {		if (this.isNew()) {			switch(this.compensation) {				case ("Floating Day") :					if (myUser.floatingDays < 1) {					err = {error : 3600, errorMessage: "You do not have any floating days left in your account."};				}				break;												case ("PTO") ://				if (this.hours > myUser.ptoHours) {//					err = {error : 3100, errorMessage: "You do not have enough hours in your account for this request."};//				}								if (this.hours < 1) {					err = {error : 3200, errorMessage: "Hours must be greater than zero."};				}								if (this.hours > 8) {					err = {error : 3200, errorMessage: "Hours can not be greater than eight."};				}				break;						} //end - switch().						/*			var tempDate = new Date(this.dateString);			if (tempDate < new Date()) {				err = {error : 3300, errorMessage: "You cannot request PTO for a date in the past."};			}			*/			} //end - if (this.isNew()).	} //end - if (myUser).		return err;}; //end - onValidate().model.Request.events.onRemove = function() {	var myCurrentUser = currentUser(), // Get the current user.	myUser = ds.User.find("id = :1", myCurrentUser.ID),	log_kind = "remove",	old_entityJSON = "",	entityJSON = "";		//if (myUser) {	if ((myUser) && (this.owner.id)) {		var theOwner = ds.User.find("id = :1", this.owner.id);		switch(this.compensation) {			case ("PTO") :			theOwner.ptoHours += this.hours;			theOwner.save();//			myUser.ptoHours += this.hours;//			myUser.save();			break;						case ("Floating Day") :			theOwner.floatingDays += 1;			theOwner.save();//			myUser.floatingDays += 1;//			myUser.save();			break;			} //end - switch(this.compensation).			entityJSON = JSON.stringify(this.toJSON());			new ds.Log({        	createDate: new Date(),             kind: log_kind,            dataClassName: "Request (" + this.id + ")",            eventName: "remove",            entity_toJSON: entityJSON,            old_entity_toJSON: old_entityJSON,            userName: myUser.fullName,            userId: myUser.id,            requestId: this.id,            ownerName: theOwner.fullName        }).save();           	} //end - if (myUser).};model.Request.events.onSave = function() {	var sessionRef = currentSession(), // Get the session.,	log_kind = "",	entityJSON = "",	old_entityJSON = "",	myCurrentUser = currentUser(), // Get the current user.	myUser = ds.User.find("id = :1", myCurrentUser.ID),	theClass = this.getDataClass(), //get the dataclass of the entity to save   	theClassName = theClass.getName(), //get the dataclass name    oldEntity = theClass(this.getKey()); //find the same entity on disk            	if ((myUser) && (this.owner.id)) {		var theOwner = ds.User.find("id = :1", this.owner.id);				if (this.isNew()) {			log_kind = "new";			this.dateRequested = new Date(this.dateString);						switch(this.compensation) {				case ("PTO") :				myUser.ptoHours -= this.hours;				myUser.save();				break;								case ("Floating Day") :				myUser.floatingDays -= 1;				myUser.save();				this.hours = 8;				break;			} //end - switch.						//Employee is requesting PTO. Send email to manager.			/**/	        var theEmailWorker = new SharedWorker("SharedWorkers/emailDaemon.js", "emailDaemon"),	        	thePort = theEmailWorker.port; // MessagePort to communicate with the email shared worker.	    	thePort.postMessage({	    		what: 'requestPTOSendMail',	    		requestorID : myUser.id,	    		requestID: this.id,	    		dateString: this.dateString,	    		comp: this.compensation,	    		hours: this.hours,	    		approveID: this.approveID,	    		approvePassword: this.approvePassword	    	});														} else {			//not new			log_kind = "update";			 if (this.status !== oldEntity.status) {			 	if (this.status === "Rejected") {			 		//Manager must have rejected it. Find the owner of the request.			 		//theOwner = ds.User.find("id = :1", this.owner.id);			 		theOwner.ptoHours += this.hours;			 		theOwner.save();			 	}			 }		} //end - this.isNew().				entityJSON = JSON.stringify(this.toJSON());		if (oldEntity) {			old_entityJSON = JSON.stringify(oldEntity.toJSON());		}				new ds.Log({        	createDate: new Date(),             kind: log_kind,            dataClassName: "Request (" + this.id + ")",            eventName: "save",            entity_toJSON: entityJSON,            old_entity_toJSON: old_entityJSON,            userName: myUser.fullName,            userId: myUser.id,            requestId: this.id,            ownerName: theOwner.fullName        }).save();   	} //end - if (myUser).	}; //end - onSave().