//Creating the Request classmodel.Request = new DataClass("Requests");//Add Task attributes.model.Request.id = new Attribute("storage", "long", "key auto");model.Request.hours = new Attribute("storage", "long", "btree");model.Request.compensation = new Attribute("storage", "string", "btree");model.Request.dateString = new Attribute("storage", "string");model.Request.dateRequested = new Attribute("storage", "date", "btree");model.Request.status = new Attribute("storage", "string", "btree");model.Request.payrollChecked = new Attribute("storage", "bool");//So manager can approve request via email.model.Request.approveID = new Attribute("storage", "uuid", {scope: "publicOnServer"}); //{scope: "publicOnServer", autogenerate: true}model.Request.approveHA1Key = new Attribute("storage", "string");model.Request.approvePassword = new Attribute("storage", "string");model.Request.owner = new Attribute("relatedEntity", "User", "User"); // relation to the User classmodel.Request.ownerName = new Attribute("alias", "string", "owner.fullName");//Collection Methods.model.Request.collectionMethods = {};model.Request.collectionMethods.acceptAllRequests = function() {	var currentRequestsCollection = this; //"this" contains our current Requests collection.	currentRequestsCollection.forEach(function(oneRequest) {		oneRequest.status = "Accepted";        oneRequest.save();	}); //end - currentRequestsCollection.forEach().		return currentRequestsCollection;}; //end - model.Request.collectionMethods.acceptRequests().model.Request.collectionMethods.acceptAllRequests.scope = "public";//Class methods.model.Request.methods = {};model.Request.methods.calendarAllRequests = function() {	var sessionRef = currentSession(),	promoteToken = sessionRef.promoteWith("Administrator"); //temporarily make this session Admin level.	return ds.Request.all();	sessionRef.unPromote(promoteToken); //Put the session back to normal.};//Class methods scope.model.Request.methods.calendarAllRequests.scope ="public";//Eventsmodel.Request.events = {};model.Request.events.onRestrictingQuery = function() {		var myCurrentUser = currentUser(), // we get the user of the current session.		sessionRef = currentSession(), // Get session.		result;		result = ds.Request.createEntityCollection(); //default to empty collection.		if (sessionRef.belongsTo("Administrator") || sessionRef.belongsTo("Manager") || sessionRef.belongsTo("Internal")) { //Internal		result = ds.Request.all();	} else {		result = ds.Request.query("owner.id = :1", myCurrentUser.ID);	}		return result;} //end - onRestrictingQuery();model.Request.events.onInit = function() {	var myCurrentUser = currentUser(), // we get the user of the current session.		myUser = ds.User.find("id = :1", myCurrentUser.ID);		if ((myCurrentUser !== null) && (myUser !== null)) {//if a user is logged in.				this.owner = myUser;	}		this.status = "Pending";	this.payrollChecked = false;		this.approvePassword = PTO.makeid();	this.approveID = generateUUID();    this.approveHA1Key = directory.computeHA1(this.approveID, this.approvePassword);}; //end - onInit().model.Request.events.onValidate = function() {	var err = null,		sessionRef = currentSession();			if (!sessionRef.belongsTo("Internal")) {			if (sessionRef.user.name === "default guest") {			err = {error : 3010, errorMessage: "Invalid session. Please refresh your browser."};			return err;		}			 	// Get the session.		var	myCurrentUser = currentUser(), // Get the current user.			myUser = ds.User.find("id = :1", myCurrentUser.ID);				if (myUser) {			if (this.isNew()) {				switch(this.compensation) {					case ("Floating Day") :						if (myUser.floatingDays < 1) {						err = {error : 3600, errorMessage: "You do not have any floating days left in your account."};					}					break;															case ("PTO") :	//				if (this.hours > myUser.ptoHours) {	//					err = {error : 3100, errorMessage: "You do not have enough hours in your account for this request."};	//				}										if (this.hours < 1) {						err = {error : 3200, errorMessage: "Hours must be greater than zero."};					}										if (this.hours > 8) {						err = {error : 3200, errorMessage: "Hours can not be greater than eight."};					}					break;								} //end - switch().								/*				var tempDate = new Date(this.dateString);				if (tempDate < new Date()) {					err = {error : 3300, errorMessage: "You cannot request PTO for a date in the past."};				}				*/				} //end - if (this.isNew()).		} //end - if (myUser).	} //if (!sessionRef.belongsTo("Internal"))		return err;}; //end - onValidate().model.Request.events.onRemove = function() {	var myCurrentUser = currentUser(), // Get the current user.	myUser = ds.User.find("id = :1", myCurrentUser.ID),	log_kind = "remove",	old_entityJSON = "",	entityJSON = "";		//if (myUser) {	if ((myUser) && (this.owner.id)) {		var theOwner = ds.User.find("id = :1", this.owner.id);				/*		switch(this.compensation) {			case ("PTO") :			theOwner.ptoHours += this.hours;			theOwner.save();//			myUser.ptoHours += this.hours;//			myUser.save();			break;						case ("Floating Day") :			theOwner.floatingDays += 1;			theOwner.save();//			myUser.floatingDays += 1;//			myUser.save();			break;			} //end - switch(this.compensation).		*/						entityJSON = JSON.stringify(this.toJSON());			new ds.Log({        	createDate: new Date(),             kind: log_kind,            dataClassName: "Request (" + this.id + ")",            eventName: "remove",            entity_toJSON: entityJSON,            old_entity_toJSON: old_entityJSON,            userName: myUser.fullName,            userId: myUser.id,            requestId: this.id,            ownerName: theOwner.fullName        }).save();           	} //end - if (myUser).};model.Request.events.onSave = function() {	var sessionRef = currentSession(); // Get the session.,		if (!sessionRef.belongsTo("Internal")) {		var log_kind = "",		entityJSON = "",		old_entityJSON = "",		myCurrentUser = currentUser(), // Get the current user.		myUser = ds.User.find("id = :1", myCurrentUser.ID),		theClass = this.getDataClass(), //get the dataclass of the entity to save	   	theClassName = theClass.getName(), //get the dataclass name	    oldEntity = theClass(this.getKey()); //find the same entity on disk	    		if ((myUser) && (this.owner.id)) {			var theOwner = ds.User.find("id = :1", this.owner.id);						if (this.isNew()) {				log_kind = "new";				this.dateRequested = new Date(this.dateString);								/*				switch(this.compensation) {					case ("PTO") :					myUser.ptoHoursSrv -= this.hours;					myUser.save();					break;										case ("Floating Day") :					myUser.floatingDaysSrv -= 1;					myUser.save();					this.hours = 8;					break;				} //end - switch.				*/												//Employee is requesting PTO. Send email to manager.				/**/		        var theEmailWorker = new SharedWorker("SharedWorkers/emailDaemon.js", "emailDaemon"),		        	thePort = theEmailWorker.port; // MessagePort to communicate with the email shared worker.		    	thePort.postMessage({		    		what: 'requestPTOSendMail',		    		requestorID : myUser.id,		    		requestID: this.id,		    		dateString: this.dateString,		    		comp: this.compensation,		    		hours: this.hours,		    		approveID: this.approveID,		    		approvePassword: this.approvePassword		    	});							} else {								//not new				log_kind = "update";				//Yes this is fragile!! REFACTOR				if (this.payrollChecked !== oldEntity.payrollChecked) {					//update user account.										if (this.payrollChecked) {						switch(this.compensation) {							case ("PTO") :							theOwner.ptoHoursSrv -= this.hours;							theOwner.save();							break;														case ("Floating Day") :							theOwner.floatingDaysSrv -= 1;							theOwner.save();							this.hours = 8;							break;						} //end - switch.					} 				}								 //if (this.status !== oldEntity.status) {				 	//if (this.status === "Rejected") {				 		//Manager must have rejected it. Find the owner of the request.				 		//theOwner = ds.User.find("id = :1", this.owner.id);				 		//theOwner.ptoHours += this.hours;				 		//theOwner.save();				 	//}				 //}			} //end - this.isNew().						entityJSON = JSON.stringify(this.toJSON());			if (oldEntity) {				old_entityJSON = JSON.stringify(oldEntity.toJSON());			}						new ds.Log({	        	createDate: new Date(), 	            kind: log_kind,	            dataClassName: "Request (" + this.id + ")",	            eventName: "save",	            entity_toJSON: entityJSON,	            old_entity_toJSON: old_entityJSON,	            userName: myUser.fullName,	            userId: myUser.id,	            requestId: this.id,	            ownerName: theOwner.fullName	        }).save();   		} //end - if (myUser).	} //end - if (!sessionRef.belongsTo("Internal")).}; //end - onSave().